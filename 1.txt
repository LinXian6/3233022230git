import torch

x_data = torch.Tensor([[1.0], [2.0], [3.0]])
y_data = torch.Tensor([[2.0], [4.0], [6.0]])

class LinearModel(torch.nn.Module):
    def __init__(self):  # 修正：添加正确的双下划线
        super(LinearModel, self).__init__()  # 修正：添加正确的双下划线
        self.linear = torch.nn.Linear(1, 1)  # 定义线性层，输入输出维度都是1

    def forward(self, x):
        y_pred = self.linear(x)
        return y_pred

model = LinearModel()

# 定义损失函数（均方误差）
criterion = torch.nn.MSELoss(size_average=False)
# 定义优化器（随机梯度下降）
optimizer = torch.optim.SGD(model.parameters(), lr=0.01)

# 训练循环
for epoch in range(1000):
    y_pred = model(x_data)  # 前向传播：计算预测值
    loss = criterion(y_pred, y_data)  # 计算损失
    print(epoch, loss.item())  # 打印当前轮次和损失值

    optimizer.zero_grad()  # 梯度清零
    loss.backward()  # 反向传播：计算梯度
    optimizer.step()  # 参数更新

# 输出训练得到的权重和偏置
print('w = ', model.linear.weight.item())
print('b = ', model.linear.bias.item())

# 测试模型
x_test = torch.Tensor([[4.0]])
y_test = model(x_test)
print('y_pred = ', y_test.data)