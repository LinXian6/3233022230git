import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib

# 简化字体设置
matplotlib.rcParams["font.family"] = "Arial"
matplotlib.rcParams["axes.unicode_minus"] = False

def read_data(file_path):  # 这里修复了参数名错误
    """读取CSV数据文件并进行详细验证"""
    try:
        df = pd.read_csv(file_path)
        print(f"成功读取数据，包含列: {df.columns.tolist()}")
        
        # 尝试自动检测x和y列
        possible_x = ['x', 'X', 'feature', '输入', '自变量']
        possible_y = ['y', 'Y', 'label', '输出', '因变量']
        
        x_col = next((col for col in possible_x if col in df.columns), None)
        y_col = next((col for col in possible_y if col in df.columns), None)
        
        if not x_col or not y_col:
            print(f"错误: 未找到合适的x和y列，数据列名为: {df.columns.tolist()}")
            return None, None
            
        x = df[x_col].values
        y = df[y_col].values
        
        print(f"使用列 {x_col} 作为x，列 {y_col} 作为y")
        print(f"x的前5个值: {x[:5]}")
        print(f"y的前5个值: {y[:5]}")
        
        return x, y
    except Exception as e:
        print(f"读取数据出错: {e}")
        return None, None

def train_model(x, y):
    """训练模型并确保收集足够的历史数据"""
    learning_rate = 0.01
    epochs = 1000
    record_every = 1  # 每轮都记录
    
    w = 0.0
    b = 0.0
    n = len(x)
    
    w_history = []
    b_history = []
    loss_history = []
    
    for i in range(epochs):
        y_pred = w * x + b
        loss = np.mean((y - y_pred) **2)
        
        w_history.append(w)
        b_history.append(b)
        loss_history.append(loss)
        
        dw = (-2/n) * np.sum(x * (y - y_pred))
        db = (-2/n) * np.sum(y - y_pred)
        
        w -= learning_rate * dw
        b -= learning_rate * db
        
        if i % 100 == 0:
            print(f"轮次 {i}, 损失: {loss:.4f}, w: {w:.4f}, b: {b:.4f}")
    
    print(f"\n训练完成，共记录了 {len(w_history)} 个w值, {len(b_history)} 个b值, {len(loss_history)} 个损失值")
    return w, b, w_history, b_history, loss_history

def plot_separate_figures(x, y, w, b, w_history, b_history, loss_history):
    """使用单独的窗口绘制每个图像"""
    if len(w_history) < 2 or len(loss_history) < 2:
        print("错误: 历史数据不足，无法绘图")
        return
    
    # 1. 绘制原始数据和拟合直线
    plt.figure(figsize=(8, 6))
    plt.scatter(x, y, color='blue', label='Data points')
    x_range = np.linspace(min(x), max(x), 100)
    plt.plot(x_range, w * x_range + b, 'r-', label=f'Fitted line: y={w:.2f}x+{b:.2f}')
    plt.title('Data and Fitted Line')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.legend()
    plt.grid(True)
    plt.show(block=False)
    
    # 2. 绘制w与loss的关系
    plt.figure(figsize=(8, 6))
    plt.plot(w_history, loss_history, 'g-')
    plt.title('w vs Loss')
    plt.xlabel('w value')
    plt.ylabel('Loss')
    plt.grid(True)
    plt.show(block=False)
    
    # 3. 绘制b与loss的关系
    plt.figure(figsize=(8, 6))
    plt.plot(b_history, loss_history, 'purple')
    plt.title('b vs Loss')
    plt.xlabel('b value')
    plt.ylabel('Loss')
    plt.grid(True)
    plt.show(block=False)
    
    # 4. 绘制损失随轮次变化
    plt.figure(figsize=(8, 6))
    plt.plot(range(len(loss_history)), loss_history, 'orange')
    plt.title('Loss During Training')
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.grid(True)
    plt.show(block=True)

def main():
    # 读取数据时传入文件名参数
    x, y = read_data('train.csv')
    if x is None or y is None:
        print("无法继续，数据读取失败")
        return
    
    w, b, w_history, b_history, loss_history = train_model(x, y)
    plot_separate_figures(x, y, w, b, w_history, b_history, loss_history)

if __name__ == "__main__":
    main()